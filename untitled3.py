# -*- coding: utf-8 -*-
"""untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/21csu062/2544c7766b5ae6e7908bb164085f8197/untitled3.ipynb
"""

import numpy as np

# Define the gridworld environment and MDP parameters
# 'S' represents the start state, 'G' represents the goal state, 'X' represents a blocked state.
# 'P' represents a terminal state with a positive reward, 'N' represents a terminal state with a negative reward.
# 'action_prob' defines the probability of taking each action, e.g., 0.25 for each of the four actions.
# 'gamma' is the discount factor.

grid = [
    ['S', 'P', 'P', 'N'],
    ['P', 'X', 'P', 'X'],
    ['X', 'P', 'X', 'X'],
    ['G', 'X', 'P', 'P']
]

actions = ['up', 'down', 'left', 'right']
action_prob = [0.25, 0.25, 0.25, 0.25]
gamma = 0.9

# Initialize the value function for each state to 0
num_rows = len(grid)
num_cols = len(grid[0])
values = np.zeros((num_rows, num_cols))

# Define a function to calculate the value of a state
def calculate_state_value(row, col):
    if grid[row][col] == 'P':
        return 1.0
    elif grid[row][col] == 'N':
        return -1.0
    elif grid[row][col] == 'G':
        return 100.0

    value = 0.0
    for i, action in enumerate(actions):
        new_row, new_col = row, col

        if action == 'up':
            new_row = max(row - 1, 0)
        elif action == 'down':
            new_row = min(row + 1, num_rows - 1)
        elif action == 'left':
            new_col = max(col - 1, 0)
        elif action == 'right':
            new_col = min(col + 1, num_cols - 1)

        reward = calculate_state_value(new_row, new_col)
        value += action_prob[i] * (reward + gamma * values[new_row][new_col])


    return value

# Perform value iteration
num_iterations = 100
for iteration in range(num_iterations):
    new_values = np.copy(values)
    for row in range(num_rows):
        for col in range(num_cols):
            if grid[row][col] not in ['S', 'X']:
                new_values[row][col] = calculate_state_value(row, col)
    values = new_values

# Print the final value function
print("Final Value Function:")
print(values)